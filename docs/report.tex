\documentclass[journal=jacsat, manuscript=article]{achemso}

\usepackage[version=3]{mhchem}
\usepackage{courier}

\newcommand*{\mycommand}[1]{\texttt{\emph{#1}}}

\author{Sabrina Jiang}
\author{Will Sherwood}
\author{Kasra Sadeghi}

\title{Backbone Compiler}

\begin{document}

\begin{abstract}

The goal of this project is two-fold: firstly, design a programming language that has enough features
to run system calls and do basic programming tasks. Secondly, the programming language should be designed with the intent of it being able to compile itself. 

We completed the first task by creating Backbone, a lisp-like language that has recursive functions, let bindings, arithmetic and more basic features. 

To complete the second task, we wrote a compiler for Backbone in C to translate it directly into LLVM bytecode. This was created in a way to make it easy to translate into Backbone later, once the language had been developed more. This would result in a self-bootstrapping compiler in Backbone.

\end{abstract}

\section{Introduction}



\section{Language}

The motivation behind the design of the Backbone language was to be
simple enough to write a simple compiler for it, but also have enough
features to be able to write a backbone compiler in the backbone language.
Through many design choices, we came to the language syntax detailed below. 

After some trial and error, we concluded that the best way to make syntax decisions was to first write the target feature in LLVM, examine the syntax, and then reverse-engineer the corresponding Backbone syntax. For example, while creating function definitions, the original syntax was as follows: 
$$\texttt{(def main (paramlist (param argc i32) (param argv i8**))}$$

However, after examining the LLVM and discussing which keywords were necessary, we decided on the following format instead:
$$\texttt{(def main (params (argc i32) (argv i8**)) i32}$$

This new format was much better. Firstly, it provides everything needed to generate the LLVM. We realized the return type was required knowledge, and added that to the definition. Secondly, it eliminates some of the unnecessary keywords.

The rest of our syntax was decided in a similar manner. The biggest consideration was balancing between inferring information, such as types of identifiers and arguments, and requiring the programmer to explicitly state the types. In the end, we generally decided that asking the programmer for more information was a better choice, as it made our jobs a bit easier. This helped eliminate the need for multiple passes through the program.

\subsection{Language terminals}

A few language terminals will be described here and used in the rest of the
language to construct most of the other features.

\begin{align}
    id &\rightarrow \textt{[a-zA-Z\_][a-zA-Z0-9\_]}\,\,\,\,\textt{(identifiers)}\\
    type &\rightarrow (i8|i16|i32|i64|u8|u16|u32|u64)*^*\,\,\,\,\textt{(types)} \\
\end{align}

\subsection{Structs}

Users can define their own struct data types as a statement. The general
grammar can be defined as follows:

\begin{align}
Struct &\rightarrow (\texttt{struct}\,id\,Fields) \\
Fields &\rightarrow Field\,Fields\,|\,Field \\
Field  &\rightarrow (id\,type)
\end{align}

An example of this syntax would be the following struct definition:

$\texttt{(struct SymbolicExpression}$

$\texttt{  (value i8*)}$

$\texttt{  (list SymbolicExpression**)}$

$\texttt{  (len u64)}$

$\texttt{  (cap u64))}$

\subsection{Calls}

Backbone supports statically typed functions that can be recursive and nested. Splitting code into
subroutines or functions is incredibly important in software engineering, and are vital to effectively
implementing system calls.

The general grammar is as follows:

$$\texttt{call}\,\,\,id\,\,\,(\texttt{types}\,type^*)\,\,\,(\texttt{args}\,\,\,Expression^*)\,\,\,type$$

Call is one of the more interesting features since it is both a statement and an expression.
The implications of this is that we can have nested calls. Since LLVM requires one expression evaluation
per instruction, calls with nested expressions need to be evaluated one at a time. We do this by
making a pass over the syntax tree and flattening expressions. This is further discussed in our section
on flattening.

An example of this syntax would be the following call statement:

$\texttt{(call printSexp void ((program Sexp*) (0 i32)))}$

\subsection{Qualified Types}

Converting between backbone and LLVM types is fairly simple. If the type is a user defined struct,
the LLVM type replaced is simply $\%struct.$ concatenated with the user defined struct type. If it
is a primitive type, or a pointer to a primitive type, they have the same representation. Here
are two examples of qualified types:

\begin{align}
\texttt{i32***}\quad &\rightarrow \quad \texttt{i32***} \\
\texttt{SymbolicExpression**}\quad &\rightarrow\quad \texttt{\%struct.SymbolicExpression**}
\end{align}

\subsection{Let}


\subsection{Conditionals}
\subsection{Return}
\subsection{Statements}
\subsection{Declarations}
\subsection{Function Definitions}
\subsection{Binary Operations}

\section{Parser}

\section{Generating LLVM}
\subsection{Structs}
\subsection{Calls}
\subsection{Qualified Types}
\subsection{Let}
\subsection{Return}
\subsection{Statements}
\subsection{Declarations}
\subsection{Function Definitions}
\subsection{Binary Operations}

\section{Conclusion}

\end{document}
